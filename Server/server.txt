#!/usr/bin/python3
from flask import Flask, request, jsonify
from flask_cors import CORS
import boto3
import sys
import ssl
import paho.mqtt.client as mqtt
import paho.mqtt.subscribe as subscribe
import json
import logging, traceback
import pymysql
import datetime
import sched, time
import threading
import time

conn = pymysql.connect(
    host='water.c5pp9bkmcuw1.ap-south-1.rds.amazonaws.com',
    user='admin',
    password='admin123',
    database='water'
)
conn.autocommit(True)
app = Flask(__name__)
cors=CORS(app,resources={r'/*':{'origins':'*'}})
cog = boto3.client('cognito-idp', region_name='ap-south-1')
cogcli='7g38fudnnbbof0mbkhmr3srpht'
#IoT_protocol_name = 'x-amzn-mqtt-ca'
#aws_iot_endpoint='a3e2e92igp1lom-ats.iot.ap-south-1.amazonaws.com'
#url = 'https://{}'.format(aws_iot_endpoint)
#ca='server/AmazonRootCA1.pem'
#cert = 'server/460be3f42b-certificate.pem.crt'
#private = 'server/460be3f42b-private.pem.key'
#logger = logging.getLogger()
#logger.setLevel(logging.DEBUG)
#handler = logging.StreamHandler(sys.stdout)
#log_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
#handler.setFormatter(log_format)
#logger.addHandler(handler)

#def on_message(client, userdata, message):
    #print('message received ' ,str(message.payload.decode('utf-8')))
#def on_subscribe(mqttc, obj, mid, granted_qos):
    #print('Subscribed: '+str(mid)+' '+str(granted_qos))

#@app.route('/test',methods=['GET','POST'])
#def test():
    #with conn.cursor(pymysql.cursors.DictCursor) as cur:
        #cur.execute('SELECT flow,tnd from water where Total IS NULL and tap_id IS NOT NULL ')
        #if cur.rowcount!=0:
            #x=cur.fetchone()
            #y=float(x['flow'])
            #z=y/60
            #flow_total=round(z,1)
            #cur.execute('update water set total="'+str(flow_total)+'" where tnd="'+str(x['tnd'])+'"')


@app.route('/signup',methods=['GET', 'POST'])
def signup():
    try:
        print('Entered')
        content = json.loads(request.data)
        cog.sign_up(
            ClientId = cogcli,
            Username = content['username'],
            Password = content['password'],
            UserAttributes=[{'Name':'email','Value':content['email']}]
        )
    except cog.exceptions.UsernameExistsException:
        return 'Username Already Exists!'
    except Exception as e:
        print('Exception: ' +str(e))
        return str(e)
    return 'True'

@app.route('/login', methods=['GET', 'POST'])
def login():
    try:
        print(request.data)
        content = json.loads(request.data)
        print(content)
        auth = cog.initiate_auth(
            AuthFlow = 'USER_PASSWORD_AUTH',
            AuthParameters = {
                'USERNAME': content['username'],
                'PASSWORD': content['password']
            },
            ClientId = cogcli
        )
        return json.dumps(auth['AuthenticationResult'])
    except cog.exceptions.UserNotConfirmedException:
        return 'User is not confirmed. Please check your mail.'
    except cog.exceptions.UserNotFoundException:
        return 'User does not exist. Check again.'
    except cog.exceptions.NotAuthorizedException:
        return 'Username/Password is incorrect'
    except Exception as e:
        print(e)
        return str(e)
flow_total=0

def dtSerializer(obj):
     if isinstance(obj, datetime.datetime):
             return(obj.isoformat())
     else:
             TypeError('Unknown serializer')



@app.route('/getDetails', methods=['GET', 'POST'])
def getDetails():
        content = json.loads(request.data)
        #fromDate = content['from']
        #toDate = content['to']
        with conn.cursor(pymysql.cursors.DictCursor) as cur:
                #cur.execute('SELECT flow,tnd from water where Total IS NULL ')
                #x=cur.fetchone()
                #y=float(x['flow'])
                #z=y/60
                #flow_total=round(z,1)
                #cur.execute('update water set total="'+str(flow_total)+'" where tnd="'+str(x['tnd'])+'"')
                #cur.execute('update water set total1=''+str(flow_total)+'' where tnd= ''+ str(x['tnd']) +'' ')
                #cur.execute('SELECT flow from water where created_at=''+ x['created_at'] +'' ')
                #z=cur.fetchone()
                total={"total":0}
                #cur.execute('SELECT tap_id,sum(Total) total from water.water where tnd >="'+str(content['from'])+'" and tnd<="'+str(content['to'])+'" ')
                cur.execute('SELECT water.tap_id,sum(Total) total from water.water JOIN water.water1 on(water.tap_id=water1.tap_id) where Floor= "'+ content['Floor']+ '" AND Building= "'+  content['Building']+ '" AND tnd >="' + str(content['from']) + '" AND tnd<="' + str(content['to']) + '" group by tap_id')
                if cur.rowcount!=0:
                        total= cur.fetchall()
                #cur.execute('UPDATE  INTO water2 SET total1=  where tap_id=''+y['tap_id ']+'' AND created_at=''+z+'' ')

        payload = {
        'Total':total
        }
        return json.dumps(payload,default=dtSerializer)
@app.route('/buildpage',methods=['GET','POST'])
def buildpage():
        content=json.loads(request.data)
        total={"total":0}
        with conn.cursor(pymysql.cursors.DictCursor) as cur:
                cur.execute('select Building,sum(Total) total from water.water JOIN water.water1 on(water.tap_id=water1.tap_id) where tnd>="'+str(content['from'])+'" AND tnd<="'+str(content['to'])+'"group by Building')
                if cur.rowcount!=0:
                        total=cur.fetchall()
        payload={
        'Total':total
        }
        return json.dumps(payload,default=dtSerializer)
@app.route('/secpage',methods=['GET','POST'])
def secpage():
        content=json.loads(request.data)
        total={"total":0}
        with conn.cursor(pymysql.cursors.DictCursor) as cur:
                cur.execute('select Floor,sum(Total) total from water.water JOIN water.water1 on(water.tap_id=water1.tap_id) where tnd>="'+str(content['from'])+'" AND tnd<="'+str(content['to'])+'"AND Building="'+content['Building']+'" group by Building,Floor')
                if cur.rowcount!=0:
                        total=cur.fetchall()
        payload={
        'Total':total
        }
        return json.dumps(payload,default=dtSerializer)
@app.route('/testSQL',methods=['GET','POST'])
def testSQL():
        content = json.loads(request.data)
        fromDate = content['from']
        toDate = content['to']
        with conn.cursor(pymysql.cursors.DictCursor) as cur:
                cur.execute('select tap_id,total from water.water where tnd >=" ' + str(fromDate)+ '" AND tnd <="'+str(toDate)+'"')
                x = cur.fetchone()
                print(x)
        payload = {'result':x }
        return json.dumps(payload, default=dtSerializer)

#def on_connect(client, userdata, flags, rc):
        #if rc == 0:
                #logger.info("Connected to broker")
                #global Connected                #Use global variable
                #Connected = True                #Signal connection
        #else:
                #logger.info("Connection failed")
#def ssl_alpn():
        #try:
                #debug print opnessl version
                #logger.info("open ssl version:{}".format(ssl.OPENSSL_VERSION))
                #ssl_context = ssl.create_default_context()
                #ssl_context.set_alpn_protocols([IoT_protocol_name])
                #ssl_context.load_verify_locations(cafile=ca)
                #ssl_context.load_cert_chain(certfile=cert, keyfile=private)
                #logger.info("done")
                #return  ssl_context
        #except Exception as e:
                #print("exception ssl_alpn()")
                #raise e


if __name__ == '__main__':
        #try:
                #mqttc = mqtt.Client()
                #ssl_context= ssl_alpn()
                #mqttc.tls_set_context(context=ssl_context)
                #mqttc.on_connect = on_connect
                #mqttc.on_subscribe = on_subscribe
                #mqttc.on_message = on_message
                #logger.info('start connect')
                #mqttc.connect(aws_iot_endpoint, port=443)
                #logger.info('connect success')
                #mqttc.subscribe('my/lambda/topic',qos=0)
                #mqttc.loop_forever()
        #except Exception as e:
                #logger.error('exception main()')
                #logger.error('e obj:{}'.format(vars(e)))
                #logger.error('message:{}'.format(e))
                #traceback.print_exc(file=sys.stdout)
        app.run(host='0.0.0.0', debug=True)
